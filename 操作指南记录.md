Day 4: 架构重构 —— Web Worker 引入
本项目将引入 Web Worker 来处理耗时的计算任务（如工作流执行、拓扑排序等），以确保 UI 线程的流畅性。

用户评审要求
IMPORTANT

本次重构涉及 Web Worker 的引入，使用 Vite 推荐的 new Worker(new URL(...)) 方式。 暂时仅实现 Ping/Pong 通信以验证连接。

方案设计

1. 类型定义
   在 src/types/worker.ts 中定义通用的 Worker 消息格式，确保主线程与 Worker 之间的通信类型安全。

2. Worker 实现
   在 src/workers/workflow.worker.ts 中实现：

监听 message 事件。
识别 { type: 'ping' } 并回复 { type: 'pong' }。 3. Worker 客户端实现
在 src/utils/worker-client.ts 中实现：

Worker 的初始化。
封装简单的发送消息接口。
打印连接成功日志。
拟进行的更改
[NEW]
worker.ts
定义 WorkerMessage 类型。

[NEW]
workflow.worker.ts
Worker 线程逻辑。

[NEW]
worker-client.ts
主线程 Worker 管理器。

验证计划
启动项目 npm run dev。
查看浏览器控制台是否出现 "Workflow Worker connected!" 以及 "Received from worker: pong" 等日志。

AST：

1. 自动构建“隐藏的执行链”（Partial Execution）
   场景： 在 n8n 里，如果你点击一个中间节点的 “Test Step”（测试此步骤）。

功能描述： n8n 不会傻乎乎地把整个流程图从头跑到尾。它会分析这个节点的代码和配置，发现它依赖了 A 节点和 B 节点。然后它会自动且仅执行 A、B 以及它们之前的必要路径，跳过那些不相关的分支。
AST 的作用： 通过搜索代码里的 $node["xxx"]，它能瞬间画出一张隐藏的“逻辑依赖图”。没有 AST，它就不知道该补跑哪些节点。 2. 循环依赖检测（Circular Dependency Detection）
场景： 用户不小心写出了“套娃”代码。

功能描述： 节点 A 的代码引用了节点 B 的数据，而节点 B 的代码又引用了节点 A 的数据。
AST 的作用： 在你点下“运行”按钮之前，AST 就像红外线防盗门一样扫一遍。它会发现这两个节点在逻辑上互相锁死，直接在 UI 上弹出一个红色的警告：“兄弟，你这代码逻辑死循环了！”
如果没有 AST： 你的浏览器会直接假死或崩溃，没有任何提示。 3. 安全沙箱与合规性检查（Static Security Audit）
场景： 防止用户（或者是恶意的流程分享者）在代码里写坏事。

功能描述： 限制用户调用危险的 JS 函数，比如 eval()、process.exit() 或者尝试访问本地硬盘。
AST 的作用： AST 可以通过“静态扫描”识别出所有的函数调用。如果发现代码里有个 require('fs')（尝试读取文件），它可以在代码运行之前直接拦截并报错。
如果没有 AST： 你只能在运行过程中拦截，那时候可能数据已经被删除了。 4. 智能变量补全与 UI 高亮（IntelliSense & Visual Hints）
场景： 用户在编辑器里打字。

功能描述： 当用户在 Code 节点输入 $node[ 时，编辑器会自动弹出一个下拉框，列出当前画布上所有可用的节点名称。
AST 的作用： 它是 IDE（开发环境）的一部分。它通过分析画布上已有的节点，动态构建出当前代码所能感知到的“世界”。
进阶： 当你在 n8n 里点击一个变量引用，画布上对应的那个源节点通常会闪烁一下。这背后的逻辑也是通过 AST 找到了两个节点的名字对应关系。 5. 自动字段映射检测（Schema Validation）
场景： 如果上游节点的输出变了。

功能描述： 假设 HTTP 节点原来返回一个 id 字段，现在改名成 uuid 了。
AST 的作用： 它可以扫描下游所有节点的表达式。如果发现代码里还在引用 $node["HTTP"].data.id，它可以在 UI 上实时标注一个黄色感叹号：“注意！这个字段可能失效了。”
